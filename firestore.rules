rules_version='2'

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isStaff() {
      return isSignedIn()
        && (
          request.auth.token.staff == true
          || (
            request.auth.token.roles is list
            && request.auth.token.roles.hasAny(["staff"])
          )
        );
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function hasOnlyKeys(keys) {
      return request.resource.data.keys().hasOnly(keys);
    }

    function changedKeysOnly(keys) {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(keys);
    }

    function isNonEmptyString(value) {
      return value is string && value.size() > 0;
    }

    function isMembershipTier(value) {
      return value is string
        && [
          "A la carte",
          "Apprentice",
          "Journeyman",
          "Master",
          "Studio",
          "Premium",
          "Founding",
          "Studio Member"
        ].hasAny([value]);
    }

    function isStage(value) {
      return value is string
        && ["GREENWARE", "BISQUE", "GLAZED", "FINISHED", "HOLD", "UNKNOWN"].hasAny([value]);
    }

    function isWareCategory(value) {
      return value is string
        && ["STONEWARE", "EARTHENWARE", "PORCELAIN", "RAKU", "OTHER", "UNKNOWN"].hasAny([value]);
    }

    function isFiringType(value) {
      return value is string && ["bisque", "glaze", "other"].hasAny([value]);
    }

    function isShelfEquivalent(value) {
      return value is number && value > 0 && value <= 32;
    }

    function isLoadStatus(value) {
      return value is string && ["queued", "loading", "loaded"].hasAny([value]);
    }

    function isBatchOwner(batchId) {
      let batchDoc = get(/databases/$(database)/documents/batches/$(batchId));
      return isSignedIn()
        && batchDoc != null
        && (
          batchDoc.data.ownerUid == request.auth.uid
          || (
            batchDoc.data.editors is list
            && batchDoc.data.editors.hasAny([request.auth.uid])
          )
        );
    }

    function canReadBatch(batchId) {
      return isStaff() || isBatchOwner(batchId);
    }

    function isThreadParticipant(threadId) {
      return isSignedIn()
        && exists(/databases/$(database)/documents/directMessages/$(threadId))
        && (
          get(/databases/$(database)/documents/directMessages/$(threadId)).data.participantUids is list
          && get(/databases/$(database)/documents/directMessages/$(threadId)).data.participantUids.hasAny([request.auth.uid])
        );
    }

    match /batches/{batchId} {
      allow read: if isStaff()
        || (isSignedIn() && resource.data.ownerUid == request.auth.uid);
      allow update: if isStaff()
        || (
          isSignedIn()
          && resource.data.ownerUid == request.auth.uid
          && request.resource.data.ownerUid == resource.data.ownerUid
          && changedKeysOnly(["collectionName", "collectionDesc", "updatedAt"])
        );
      allow create, delete: if false;

      match /timeline/{eventId} {
        allow read: if canReadBatch(batchId);
        allow write: if false;
      }

      // Keep nested piece subtree match explicit so read access is evaluated for
      // both piece docs and their nested detail collections.
      match /pieces/{pieceId} {
        allow read: if canReadBatch(batchId);

        match /{document=**} {
          allow read: if canReadBatch(batchId);
        }
      }
    }

    match /batches/{batchId}/pieces/{pieceId} {
      allow read: if canReadBatch(batchId);
      allow create: if canReadBatch(batchId)
        && hasOnlyKeys([
          "pieceCode",
          "shortDesc",
          "ownerName",
          "stage",
          "wareCategory",
          "isArchived",
          "createdAt",
          "updatedAt"
        ])
        && isNonEmptyString(request.resource.data.pieceCode)
        && isNonEmptyString(request.resource.data.shortDesc)
        && isNonEmptyString(request.resource.data.ownerName)
        && isStage(request.resource.data.stage)
        && isWareCategory(request.resource.data.wareCategory)
        && request.resource.data.isArchived is bool
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;
      allow update: if canReadBatch(batchId)
        && changedKeysOnly([
          "shortDesc",
          "ownerName",
          "stage",
          "wareCategory",
          "isArchived",
          "selectedGlazes",
          "clientRating",
          "clientRatingUpdatedAt",
          "updatedAt"
        ])
        && request.resource.data.pieceCode == resource.data.pieceCode
        && request.resource.data.createdAt == resource.data.createdAt
        && isNonEmptyString(request.resource.data.shortDesc)
        && isNonEmptyString(request.resource.data.ownerName)
        && isStage(request.resource.data.stage)
        && isWareCategory(request.resource.data.wareCategory)
        && request.resource.data.isArchived is bool
        && request.resource.data.updatedAt is timestamp
        && (
          !request.resource.data.keys().hasAny(["clientRating"])
          || (
            request.resource.data.clientRating is int
            && request.resource.data.clientRating >= 1
            && request.resource.data.clientRating <= 5
          )
        )
        && (
          !request.resource.data.keys().hasAny(["clientRatingUpdatedAt"])
          || request.resource.data.clientRatingUpdatedAt is timestamp
        )
        && (
          !request.resource.data.keys().hasAny(["selectedGlazes"])
          || request.resource.data.selectedGlazes is list
        );
      allow delete: if false;

      match /clientNotes/{noteId} {
        allow read: if canReadBatch(batchId);
        allow create: if (
          isStaff()
          || (
            isBatchOwner(batchId)
            && request.resource.data.authorUid == request.auth.uid
            && hasOnlyKeys(["text", "at", "authorUid", "authorName", "searchTokens"])
            && isNonEmptyString(request.resource.data.text)
            && request.resource.data.at is timestamp
          )
        );
        allow update: if (
          isStaff()
          || (
            isBatchOwner(batchId)
            && resource.data.authorUid == request.auth.uid
            && changedKeysOnly(["text", "updatedAt", "searchTokens"])
            && isNonEmptyString(request.resource.data.text)
            && request.resource.data.updatedAt is timestamp
          )
        );
        allow delete: if false;
      }

      match /studioNotes/{noteId} {
        allow read: if canReadBatch(batchId);
        allow create: if isStaff()
          && hasOnlyKeys(["text", "at", "authorUid", "authorName", "searchTokens"])
          && isNonEmptyString(request.resource.data.text)
          && request.resource.data.at is timestamp;
        allow update: if isStaff()
          && changedKeysOnly(["text", "updatedAt", "searchTokens"])
          && isNonEmptyString(request.resource.data.text)
          && request.resource.data.updatedAt is timestamp;
        allow delete: if false;
      }

      match /audit/{eventId} {
        allow read: if canReadBatch(batchId);
        allow create: if canReadBatch(batchId)
          && hasOnlyKeys(["type", "at", "actorUid", "actorName", "notes", "noteStream", "noteId"])
          && isNonEmptyString(request.resource.data.type)
          && request.resource.data.actorUid == request.auth.uid
          && request.resource.data.at is timestamp;
        allow update, delete: if false;
      }

      match /media/{mediaId} {
        allow read: if canReadBatch(batchId);
        allow create: if canReadBatch(batchId)
          && hasOnlyKeys(["url", "type", "title", "notes", "createdAt", "updatedAt"])
          && isNonEmptyString(request.resource.data.url)
          && request.resource.data.createdAt is timestamp;
        allow update, delete: if false;
      }
    }

    match /faqItems/{faqId} {
      allow read: if request.auth != null;
      allow write: if false;
    }

    match /supportRequests/{requestId} {
      allow create: if isSignedIn()
        && request.resource.data.uid == request.auth.uid
        && hasOnlyKeys([
          "uid",
          "subject",
          "body",
          "category",
          "status",
          "urgency",
          "channel",
          "createdAt",
          "displayName",
          "email"
        ])
        && isNonEmptyString(request.resource.data.subject)
        && isNonEmptyString(request.resource.data.body)
        && request.resource.data.status == "new"
        && request.resource.data.createdAt is timestamp;
      allow read: if isStaff();
      allow update: if isStaff();
      allow delete: if false;
    }

    match /eventTemplates/{templateId} {
      allow read, write: if false;
    }

    match /events/{eventId} {
      allow read: if isSignedIn()
        && (resource.data.status == "published" || isStaff());
      allow write: if false;
    }

    match /eventSignups/{signupId} {
      allow read: if isStaff()
        || (isSignedIn() && resource.data.uid == request.auth.uid);
      allow create, update, delete: if false;
    }

    match /eventCharges/{chargeId} {
      allow read: if isStaff()
        || (isSignedIn() && resource.data.uid == request.auth.uid);
      allow write: if false;
    }

    match /materialsOrders/{orderId} {
      allow read: if isStaff()
        || (isSignedIn() && resource.data.uid == request.auth.uid);
      allow write: if false;
    }

    match /profiles/{profileId} {
      allow read: if isOwner(profileId) || isStaff();
      allow create, update: if isOwner(profileId)
        && hasOnlyKeys([
          "displayName",
          "preferredKilns",
          "membershipTier",
          "membershipSince",
          "membershipExpiresAt",
          "notifyKiln",
          "notifyClasses",
          "notifyPieces",
          "notifyReservations",
          "personalNotes",
          "studioNotes",
          "uiTheme",
          "uiEnhancedMotion",
          "updatedAt"
        ])
        && request.resource.data.updatedAt is timestamp
        && (
          !request.resource.data.keys().hasAny(["membershipTier"])
          || isMembershipTier(request.resource.data.membershipTier)
        )
        && (
          !request.resource.data.keys().hasAny(["membershipSince"])
          || request.resource.data.membershipSince is timestamp
        )
        && (
          !request.resource.data.keys().hasAny(["membershipExpiresAt"])
          || request.resource.data.membershipExpiresAt is timestamp
        )
        && (
          !request.resource.data.keys().hasAny(["notifyReservations"])
          || request.resource.data.notifyReservations is bool
        )
        && (
          !request.resource.data.keys().hasAny(["personalNotes"])
          || request.resource.data.personalNotes is string
          || request.resource.data.personalNotes == null
        )
        && (
          !request.resource.data.keys().hasAny(["studioNotes"])
          || request.resource.data.studioNotes is string
          || request.resource.data.studioNotes == null
        )
        && (
          !request.resource.data.keys().hasAny(["uiTheme"])
          || request.resource.data.uiTheme is string
          || request.resource.data.uiTheme == null
        )
        && (
          !request.resource.data.keys().hasAny(["uiTheme"])
          || request.resource.data.uiTheme == null
          || request.resource.data.uiTheme in ["portal", "memoria"]
        )
        && (
          !request.resource.data.keys().hasAny(["uiEnhancedMotion"])
          || request.resource.data.uiEnhancedMotion is bool
          || request.resource.data.uiEnhancedMotion == null
        )
        && (
          resource == null
          || !request.resource.data.keys().hasAny(["membershipSince"])
          || request.resource.data.membershipSince == resource.data.membershipSince
        )
        && (
          resource == null
          || !request.resource.data.keys().hasAny(["membershipExpiresAt"])
          || request.resource.data.membershipExpiresAt == resource.data.membershipExpiresAt
        )
        && (
          resource == null
          || !request.resource.data.keys().hasAny(["studioNotes"])
          || request.resource.data.studioNotes == resource.data.studioNotes
        );
      allow delete: if false;
    }

    match /reservations/{reservationId} {
      allow create: if isSignedIn()
        && request.resource.data.ownerUid == request.auth.uid
        && request.resource.data.status == "REQUESTED"
        && hasOnlyKeys([
          "ownerUid",
          "status",
          "firingType",
          "shelfEquivalent",
          "preferredWindow",
          "linkedBatchId",
          "createdAt",
          "updatedAt"
        ])
        && (
          request.resource.data.linkedBatchId == null
          || isBatchOwner(request.resource.data.linkedBatchId)
        )
        && isFiringType(request.resource.data.firingType)
        && isShelfEquivalent(request.resource.data.shelfEquivalent)
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;
      allow read: if isStaff()
        || (isSignedIn() && resource.data.ownerUid == request.auth.uid);
      allow update: if isStaff()
        && changedKeysOnly(["status", "updatedAt", "staffNotes", "loadStatus"])
        && request.resource.data.updatedAt is timestamp
        && (
          !request.resource.data.keys().hasAny(["loadStatus"])
          || isLoadStatus(request.resource.data.loadStatus)
        );
      allow delete: if false;
    }

    match /kilnLaunchRequests/{requestId} {
      allow read: if isStaff()
        || (isSignedIn() && resource.data.uid == request.auth.uid);
      allow create: if isSignedIn()
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.status == "queued"
        && request.resource.data.urgency is string
        && ["asap", "next"].hasAny([request.resource.data.urgency])
        && request.resource.data.halfShelves is number
        && request.resource.data.halfShelves >= 1
        && request.resource.data.halfShelves <= 4
        && hasOnlyKeys([
          "uid",
          "userDisplayName",
          "halfShelves",
          "clayBody",
          "notes",
          "urgency",
          "status",
          "kilnId",
          "createdAt",
          "updatedAt"
        ])
        && isNonEmptyString(request.resource.data.clayBody)
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;
      allow update: if isStaff()
        && request.resource.data.uid == resource.data.uid
        && changedKeysOnly(["status", "updatedAt"])
        && request.resource.data.updatedAt is timestamp;
      allow delete: if false;
    }

    match /kilns/{kilnId} {
      allow read: if isSignedIn();
      allow write: if isStaff();
    }

    match /kilnFirings/{firingId} {
      allow read: if isSignedIn();
      allow write: if isStaff();
    }

    match /firingsCalendarEvents/{eventId} {
      allow read: if isSignedIn();
      allow write: if false;
    }

    match /announcements/{announcementId} {
      allow read: if isSignedIn();
      allow create: if isStaff();
      allow update: if isStaff()
        || (
          isSignedIn()
          && changedKeysOnly(["readBy"])
          && request.resource.data.readBy is list
          && (
            !(resource.data.readBy is list)
            || request.resource.data.readBy.hasAll(resource.data.readBy)
          )
          && request.resource.data.readBy.hasAny([request.auth.uid])
          && (
            !(resource.data.readBy is list)
            || (
              resource.data.readBy.hasAny([request.auth.uid])
              && request.resource.data.readBy.size() == resource.data.readBy.size()
            )
            || (
              !resource.data.readBy.hasAny([request.auth.uid])
              && request.resource.data.readBy.size() == resource.data.readBy.size() + 1
            )
          )
        );
      allow delete: if false;
    }

    match /users/{userId} {
      allow read: if isOwner(userId) || isStaff();
      allow write: if false;
    }

    match /users/{userId}/prefs/{prefId} {
      allow read: if isOwner(userId);
      allow create, update: if isOwner(userId)
        && prefId == "notifications"
        && request.resource.data.enabled is bool
        && request.resource.data.channels is map
        && request.resource.data.events is map
        && request.resource.data.frequency is map
        && request.resource.data.channels.keys().hasOnly([
          "inApp",
          "email",
          "push",
          "sms"
        ])
        && request.resource.data.events.keys().hasOnly([
          "kilnUnloaded",
          "kilnUnloadedBisque",
          "kilnUnloadedGlaze"
        ])
        && request.resource.data.frequency.keys().hasOnly([
          "mode",
          "digestHours"
        ])
        && (
          !request.resource.data.keys().hasAny(["quietHours"])
          || (
            request.resource.data.quietHours is map
            && request.resource.data.quietHours.keys().hasOnly([
              "enabled",
              "startLocal",
              "endLocal",
              "timezone"
            ])
          )
        )
        && request.resource.data.updatedAt is timestamp;
      allow delete: if false;
    }

    match /users/{userId}/notifications/{notificationId} {
      allow read: if isOwner(userId);
      allow update: if isOwner(userId)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["readAt", "updatedAt"])
        && (
          !request.resource.data.keys().hasAny(["readAt"])
          || request.resource.data.readAt is timestamp
          || request.resource.data.readAt == null
        )
        && (
          !request.resource.data.keys().hasAny(["updatedAt"])
          || request.resource.data.updatedAt is timestamp
        );
      allow create, delete: if false;
    }

    match /notificationJobs/{jobId} {
      allow read, write: if false;
    }

    match /rateLimits/{rateId} {
      allow read, write: if false;
    }

    match /mail/{mailId} {
      allow read, write: if false;
    }

    match /directMessages/{threadId} {
      allow read: if isStaff()
        || (
          isSignedIn()
          && request.auth.uid in resource.data.participantUids
        );
      allow create: if isSignedIn()
        && request.resource.data.participantUids is list
        && request.resource.data.participantUids.hasAny([request.auth.uid])
        && hasOnlyKeys([
          "subject",
          "kind",
          "participantUids",
          "createdAt",
          "updatedAt",
          "lastMessagePreview",
          "lastMessageAt",
          "lastMessageId",
          "lastSenderName",
          "lastSenderEmail",
          "references",
          "lastReadAtByUid"
        ]);
      allow update: if (
          isStaff()
          || (
            isSignedIn()
            && request.auth.uid in resource.data.participantUids
          )
        )
        && request.resource.data.participantUids == resource.data.participantUids
        && changedKeysOnly([
          "subject",
          "updatedAt",
          "lastMessagePreview",
          "lastMessageAt",
          "lastMessageId",
          "lastSenderName",
          "lastSenderEmail",
          "references",
          "lastReadAtByUid"
        ]);
      allow delete: if false;

      match /messages/{messageId} {
        allow read: if isStaff() || isThreadParticipant(threadId);
        allow create: if (isStaff() || isThreadParticipant(threadId))
          && request.resource.data.fromUid == request.auth.uid
          && hasOnlyKeys([
            "messageId",
            "subject",
            "body",
            "fromUid",
            "fromName",
            "fromEmail",
            "replyToEmail",
            "toUids",
            "toEmails",
            "sentAt",
            "inReplyTo",
            "references"
          ])
          && isNonEmptyString(request.resource.data.body)
          && request.resource.data.sentAt is timestamp;
        allow update, delete: if false;
      }
    }

    match /materialsProducts/{productId} {
      allow read: if isSignedIn();
      allow write: if isStaff();
    }

    match /libraryItems/{itemId} {
      allow read: if isSignedIn();
      allow write: if isStaff();
    }

    match /libraryRequests/{requestId} {
      allow create: if isSignedIn()
        && request.resource.data.requesterUid == request.auth.uid
        && request.resource.data.status == "pending_approval"
        && hasOnlyKeys([
          "itemId",
          "itemTitle",
          "type",
          "status",
          "requesterUid",
          "requesterName",
          "requesterEmail",
          "requestedAt",
          "updatedAt",
          "notes"
        ])
        && request.resource.data.requestedAt is timestamp
        && request.resource.data.updatedAt is timestamp;
      allow read: if isStaff()
        || (isSignedIn() && resource.data.requesterUid == request.auth.uid);
      allow update: if isStaff();
      allow delete: if false;
    }

    match /libraryLoans/{loanId} {
      allow read: if (isSignedIn() && resource.data.borrowerUid == request.auth.uid) || isStaff();
      allow create, update: if isStaff();
      allow delete: if false;
    }

    match /libraryDonationRequests/{requestId} {
      allow create: if isSignedIn()
        && request.resource.data.donorUid == request.auth.uid
        && request.resource.data.status == "pending"
        && hasOnlyKeys([
          "isbn",
          "title",
          "author",
          "format",
          "notes",
          "status",
          "donorUid",
          "donorName",
          "donorEmail",
          "createdAt",
          "updatedAt"
        ])
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;
      allow read: if isStaff()
        || (isSignedIn() && resource.data.donorUid == request.auth.uid);
      allow update: if isStaff();
      allow delete: if false;
    }

    match /comboTiles/{comboId} {
      allow read: if isSignedIn();
      allow write: if isStaff();
    }

    match /singleTiles/{tileId} {
      allow read: if isSignedIn();
      allow write: if isStaff();
    }

    match /glazes/{glazeId} {
      allow read: if isSignedIn();
      allow write: if isStaff();
    }

    match /config/studioJukebox {
      allow read: if isStaff();
      allow write: if isStaff();
    }

    match /config/stripe {
      allow read: if isStaff();
      allow write: if false;

      match /stripe_audit/{auditId} {
        allow read: if isStaff();
        allow write: if false;
      }
    }

    match /config/moderationPolicy {
      allow read: if isSignedIn();
      allow write: if false;
    }

    match /config/communitySafety {
      allow read: if isStaff();
      allow write: if false;
    }

    match /moderationPolicyVersions/{versionId} {
      allow read: if isSignedIn();
      allow write: if false;
    }

    match /moderationPolicyAuditLogs/{logId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /communitySafetyAuditLogs/{logId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /communityReports/{reportId} {
      allow read: if isStaff()
        || (isSignedIn() && resource.data.reporterUid == request.auth.uid);
      allow create, update, delete: if false;

      match /internalNotes/{noteId} {
        allow read: if isStaff();
        allow create, update, delete: if false;
      }

      match /actions/{actionId} {
        allow read: if isStaff();
        allow create, update, delete: if false;
      }
    }

    match /communityReportAppeals/{appealId} {
      allow read: if isStaff()
        || (isSignedIn() && resource.data.reporterUid == request.auth.uid);
      allow create, update, delete: if false;
    }

    match /communityReportAuditLogs/{auditId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /communityReportDedupe/{dedupeId} {
      allow read, write: if false;
    }

    match /communityReportTargetSignals/{signalId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /communityReportHousekeeping/{jobId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /agentClients/{clientId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /agentClientAuditLogs/{logId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /securityAudit/{logId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /integrationTokenAudit/{logId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /delegations/{delegationId} {
      allow read: if isStaff()
        || (isSignedIn() && resource.data.ownerUid == request.auth.uid);
      allow write: if false;
    }

    match /auditEvents/{auditId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /delegatedTokenNonces/{nonceId} {
      allow read, write: if false;
    }

    match /communityFeedOverrides/{overrideId} {
      allow read: if isStaff();
      allow write: if false;
    }

    match /studioJukebox/tracks/items/{trackId} {
      allow read: if isStaff();
      allow write: if isStaff();
    }

    match /studioJukebox/queue/items/{itemId} {
      allow read: if isSignedIn();
      allow write: if false;
    }

    match /studioJukebox/votes/items/{itemId}/byUid/{uid} {
      allow read, write: if false;
    }

    match /studioJukebox/state {
      allow read: if isSignedIn();
      allow write: if isStaff();
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
