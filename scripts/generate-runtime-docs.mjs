#!/usr/bin/env node

import { createHash } from "node:crypto";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";

import { resolveStudioBrainNetworkProfile } from "./studio-network-profile.mjs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const REPO_ROOT = resolve(__dirname, "..");
const DEFAULT_SCHEMA_PATH = resolve(REPO_ROOT, "studio-brain/.env.contract.schema.json");
const DEFAULT_PROFILE_PATH = resolve(REPO_ROOT, "studio-brain/.env.network.profile");
const DEFAULT_OUTPUT_PATH = resolve(REPO_ROOT, "docs/generated/studiobrain-runtime-contract.generated.md");

const args = parseArgs(process.argv.slice(2));

try {
  const schema = JSON.parse(readFileSync(resolvePath(args.schemaPath, DEFAULT_SCHEMA_PATH), "utf8"));
  const profilePath = resolvePath(args.profilePath, DEFAULT_PROFILE_PATH);
  const profileEnv = parseEnvFile(profilePath);
  const network = resolveStudioBrainNetworkProfile({ env: {}, profilePath });
  const generated = renderDocument({ schema, profileEnv, network, profilePath, schemaPath: resolvePath(args.schemaPath, DEFAULT_SCHEMA_PATH) });
  const outputPath = resolvePath(args.outputPath, DEFAULT_OUTPUT_PATH);

  const current = existsSync(outputPath) ? readFileSync(outputPath, "utf8") : "";
  const changed = current !== generated;
  const digest = createHash("sha256").update(generated).digest("hex");
  const sourceDigest = buildSourceDigest(schema, profileEnv);

  if (args.check) {
    const diff = changed ? firstDiff(current, generated) : null;
    const report = {
      status: changed ? "fail" : "pass",
      checkMode: true,
      outputPath: relativePath(outputPath),
      changed,
      digest,
      sourceDigest,
      diff,
    };
    emit(report, args.json);
    process.exit(changed ? 1 : 0);
  }

  mkdirSync(dirname(outputPath), { recursive: true });
  writeFileSync(outputPath, generated, "utf8");
  const report = {
    status: "pass",
    checkMode: false,
    outputPath: relativePath(outputPath),
    changed,
    digest,
    sourceDigest,
  };
  emit(report, args.json);
  process.exit(0);
} catch (error) {
  const report = {
    status: "fail",
    checkMode: Boolean(args.check),
    message: error instanceof Error ? error.message : String(error),
  };
  emit(report, args.json);
  process.exit(1);
}

function renderDocument({ schema, profileEnv, network, profilePath, schemaPath }) {
  const variables = schema?.variables && typeof schema.variables === "object" ? schema.variables : {};
  const keys = Object.keys(variables).sort();
  const required = keys.filter((key) => variables[key]?.required === true);
  const optional = keys.length - required.length;
  const sensitive = keys.filter((key) => variables[key]?.sensitive === true);

  const endpoints = [
    ["Studio Brain API", network.baseUrl],
    ["Functions emulator", `http://${network.host}:5001/monsoonfire-portal/us-central1`],
    ["Auth emulator", `${network.host}:9099`],
    ["Firestore emulator", `${network.host}:8080`],
  ];

  const profileRows = [
    ["Requested profile", network.requestedProfile || network.profile],
    ["Resolved profile", network.profile],
    ["Network mode", network.networkTargetMode],
    ["Resolved host", network.host],
    ["Resolved port", String(network.port)],
    ["Resolved base URL", network.baseUrl],
    ["Host source", network.hostSource || "n/a"],
    ["Profile source", network.profileSource || "n/a"],
    ["Host state file", profileEnv.STUDIO_BRAIN_HOST_STATE_FILE || network.hostStateFile || ".studiobrain-host-state.json"],
    ["Static LAN assignment", profileEnv.STUDIO_BRAIN_STATIC_IP || "(not set)"],
  ];

  const envTable = keys.map((key) => {
    const definition = variables[key] || {};
    const defaultValue = formatDefault(definition.default, Boolean(definition.sensitive));
    const requiredFlag = definition.required ? "yes" : "no";
    const type = definition.type || "string";
    return `| ${key} | ${type} | ${requiredFlag} | ${defaultValue} |`;
  });

  return [
    "# Studiobrain Runtime Contract (Generated)",
    "",
    "> Generated by `npm run docs:contract`. Do not hand-edit.",
    "",
    "## Sources",
    `- Schema: \`${relativePath(schemaPath)}\``,
    `- Network profile: \`${relativePath(profilePath)}\``,
    "",
    "## Contract Summary",
    `- Schema version: \`${schema.version || "unknown"}\``,
    `- Variables tracked: \`${keys.length}\``,
    `- Required variables: \`${required.length}\``,
    `- Optional variables: \`${optional}\``,
    `- Sensitive variables (redacted defaults): \`${sensitive.length}\``,
    "",
    "## Network Profile Snapshot",
    "| Field | Value |",
    "| --- | --- |",
    ...profileRows.map(([field, value]) => `| ${field} | ${escapeCell(value)} |`),
    "",
    "## Core Endpoint Contract",
    "| Surface | Value |",
    "| --- | --- |",
    ...endpoints.map(([surface, value]) => `| ${surface} | ${escapeCell(value)} |`),
    "",
    "## Environment Variable Contract",
    "| Key | Type | Required | Default |",
    "| --- | --- | --- | --- |",
    ...envTable,
    "",
    "## Update Workflow",
    "1. Edit `studio-brain/.env.contract.schema.json` or `studio-brain/.env.network.profile`.",
    "2. Run `npm run docs:contract`.",
    "3. Validate drift with `npm run docs:contract:check` in PR checks.",
    "",
    `Source digest: \`${buildSourceDigest(schema, profileEnv)}\``,
    "",
  ].join("\n");
}

function parseEnvFile(path) {
  const values = {};
  if (!path || !existsSync(path)) {
    return values;
  }
  const text = readFileSync(path, "utf8");
  for (const rawLine of text.split(/\r?\n/)) {
    const line = rawLine.trim();
    if (!line || line.startsWith("#")) {
      continue;
    }
    const index = line.indexOf("=");
    if (index < 0) {
      continue;
    }
    const key = line.slice(0, index).trim();
    if (!key) {
      continue;
    }
    let value = line.slice(index + 1).trim();
    if (
      (value.startsWith("\"") && value.endsWith("\"")) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }
    values[key] = value;
  }
  return values;
}

function buildSourceDigest(schema, profileEnv) {
  const normalized = JSON.stringify({
    schemaVersion: schema?.version || "unknown",
    keys: Object.keys(schema?.variables || {}).sort(),
    profile: Object.keys(profileEnv || {})
      .sort()
      .reduce((acc, key) => {
        acc[key] = profileEnv[key];
        return acc;
      }, {}),
  });
  return createHash("sha256").update(normalized).digest("hex");
}

function parseArgs(rawArgs) {
  const parsed = {
    check: false,
    json: false,
    outputPath: "",
    schemaPath: "",
    profilePath: "",
  };

  for (let i = 0; i < rawArgs.length; i += 1) {
    const arg = rawArgs[i];
    if (arg === "--check") {
      parsed.check = true;
      continue;
    }
    if (arg === "--json") {
      parsed.json = true;
      continue;
    }
    if (arg === "--output" && rawArgs[i + 1]) {
      parsed.outputPath = rawArgs[i + 1];
      i += 1;
      continue;
    }
    if (arg === "--schema" && rawArgs[i + 1]) {
      parsed.schemaPath = rawArgs[i + 1];
      i += 1;
      continue;
    }
    if (arg === "--profile" && rawArgs[i + 1]) {
      parsed.profilePath = rawArgs[i + 1];
      i += 1;
      continue;
    }
    if (arg === "--help" || arg === "-h") {
      printHelp();
      process.exit(0);
    }
  }

  return parsed;
}

function printHelp() {
  process.stdout.write("Usage: node ./scripts/generate-runtime-docs.mjs [flags]\n");
  process.stdout.write("Flags:\n");
  process.stdout.write("  --check\n");
  process.stdout.write("  --json\n");
  process.stdout.write("  --output <path>\n");
  process.stdout.write("  --schema <path>\n");
  process.stdout.write("  --profile <path>\n");
}

function resolvePath(value, fallback) {
  if (!value) {
    return fallback;
  }
  return resolve(REPO_ROOT, value);
}

function firstDiff(current, next) {
  const currentLines = String(current || "").split(/\r?\n/);
  const nextLines = String(next || "").split(/\r?\n/);
  const max = Math.max(currentLines.length, nextLines.length);
  for (let i = 0; i < max; i += 1) {
    if ((currentLines[i] || "") !== (nextLines[i] || "")) {
      return {
        line: i + 1,
        current: currentLines[i] || "",
        next: nextLines[i] || "",
      };
    }
  }
  return null;
}

function formatDefault(value, sensitive) {
  if (sensitive) {
    return "(redacted)";
  }
  if (value === undefined) {
    return "";
  }
  if (value === null) {
    return "null";
  }
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  return String(value);
}

function escapeCell(value) {
  return String(value ?? "").replace(/\|/g, "\\|");
}

function relativePath(absPath) {
  return absPath.startsWith(`${REPO_ROOT}/`) ? absPath.slice(REPO_ROOT.length + 1) : absPath;
}

function emit(payload, asJson) {
  if (asJson) {
    process.stdout.write(`${JSON.stringify(payload, null, 2)}\n`);
    return;
  }

  process.stdout.write(`docs contract: ${String(payload.status || "unknown").toUpperCase()}\n`);
  if (payload.outputPath) {
    process.stdout.write(`  output: ${payload.outputPath}\n`);
  }
  if (payload.changed !== undefined) {
    process.stdout.write(`  changed: ${payload.changed ? "yes" : "no"}\n`);
  }
  if (payload.diff?.line) {
    process.stdout.write(`  first diff line: ${payload.diff.line}\n`);
  }
  if (payload.message) {
    process.stdout.write(`  message: ${payload.message}\n`);
  }
}
